#!/bin/bash

# DataLink Client - File upload/download tool
# Usage: 
#   dtlk up <file/directory> [additional files/directories...]
#   dtlk down <8-digit-id> [download-directory]

set -e

progress_pid=""
compress_pid=""
extract_pid=""
temp_archive=""
temp_file=""
temp_extract_dir=""

cleanup() {
    print_info "Cancelling operation..."
    
    [ -n "$progress_pid" ] && kill "$progress_pid" 2>/dev/null || true
    [ -n "$compress_pid" ] && kill "$compress_pid" 2>/dev/null || true
    [ -n "$extract_pid" ] && kill "$extract_pid" 2>/dev/null || true
    
    [ -n "$temp_archive" ] && [ -f "$temp_archive" ] && rm -f "$temp_archive"
    [ -n "$temp_file" ] && [ -f "$temp_file" ] && rm -f "$temp_file"
    [ -n "$temp_extract_dir" ] && [ -d "$temp_extract_dir" ] && rm -rf "$temp_extract_dir"
    
    rm -f /tmp/dtlk_compress_progress_* 2>/dev/null || true
    rm -f /tmp/dtlk_upload_progress_* 2>/dev/null || true
    rm -f /tmp/dtlk_download_progress_* 2>/dev/null || true
    rm -f /tmp/dtlk_extract_progress_* 2>/dev/null || true
    rm -f /tmp/dtlk_http_code* 2>/dev/null || true
    rm -f /tmp/dtlk_response_* 2>/dev/null || true
    rm -f /tmp/dtlk_renamed_*.txt 2>/dev/null || true
    
    echo
    print_error "Operation cancelled"
    exit 1
}


trap cleanup INT TERM

SERVER_URL="https://datalink.ga111o.com"
SCRIPT_NAME="dtlk"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_info() {
    echo -e "${YELLOW}$1${NC}"
}

print_progress() {
    echo -e "${BLUE}$1${NC}"
}

calculate_size() {
    local total_size=0
    for item in "$@"; do
        if [ -f "$item" ]; then
            total_size=$((total_size + $(stat -c%s "$item" 2>/dev/null || echo 0)))
        elif [ -d "$item" ]; then
            total_size=$((total_size + $(du -sb "$item" 2>/dev/null | cut -f1 || echo 0)))
        fi
    done
    echo "$total_size"
}

format_bytes() {
    local bytes="$1"
    local units=("B" "KB" "MB" "GB")
    local unit_index=0
    
    while [ "$bytes" -ge 1024 ] && [ "$unit_index" -lt 4 ]; do
        bytes=$((bytes / 1024))
        unit_index=$((unit_index + 1))
    done
    
    echo "${bytes}${units[$unit_index]}"
}

show_progress() {
    local current="$1"
    local total="$2"
    local operation="$3"
    
    if [ "$total" -eq 0 ]; then
        return
    fi
    
    local percentage=$((current * 100 / total))
    local bar_length=50
    local filled_length=$((percentage * bar_length / 100))
    local empty_length=$((bar_length - filled_length))
    
    local bar=""
    for ((i=0; i<filled_length; i++)); do
        bar="${bar}█"
    done
    for ((i=0; i<empty_length; i++)); do
        bar="${bar}░"
    done
    
    local current_formatted=$(format_bytes "$current")
    local total_formatted=$(format_bytes "$total")
    
    printf "\r${BLUE}%s: [%s] %d%% (%s/%s)${NC}" "$operation" "$bar" "$percentage" "$current_formatted" "$total_formatted"
}

show_spinner() {
    local operation="$1"
    local spinner_chars="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
    local i=0
    
    while true; do
        local char=${spinner_chars:$((i % ${#spinner_chars})):1}
        printf "\r${BLUE}%s %s${NC}" "$char" "$operation"
        i=$((i + 1))
        sleep 0.1
    done
}


check_dependencies() {
    local missing_tools=()
    
    command -v curl >/dev/null 2>&1 || missing_tools+=("curl")
    command -v tar >/dev/null 2>&1 || missing_tools+=("tar")
    
    if [ ${#missing_tools[@]} -ne 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        echo "Please install the missing tools and try again."
        exit 1
    fi
}

upload_files() {
    local files=("$@")
    
    if [ ${#files[@]} -eq 0 ]; then
        print_error "No files or directories specified for upload"
        echo "Usage: $SCRIPT_NAME up <file/directory> [additional files/directories...]"
        exit 1
    fi
    
    for file in "${files[@]}"; do
        if [ ! -e "$file" ]; then
            print_error "File or directory does not exist: $file"
            exit 1
        fi
    done
    
    local total_size=$(calculate_size "${files[@]}")
    print_info "Total size to upload: $(format_bytes "$total_size")"
    echo
    
    local timestamp=$(date +%s)
    temp_archive="/tmp/dtlk_upload_${timestamp}.tar.gz"
    
    print_info "Compressing files..."
    
    local compress_progress_file="/tmp/dtlk_compress_progress_${timestamp}"
    
    (
        local estimated_final_size=$((total_size * 30 / 100))
        [ "$estimated_final_size" -lt 1024 ] && estimated_final_size=1024
        
        while [ ! -f "$temp_archive" ]; do
            sleep 0.1
        done
        
        while kill -0 "$compress_pid" 2>/dev/null; do
            if [ -f "$temp_archive" ]; then
                local current_size=$(stat -c%s "$temp_archive" 2>/dev/null || echo 0)
                
                if [ "$current_size" -gt "$estimated_final_size" ]; then
                    estimated_final_size=$((current_size + current_size / 10))
                fi
                
                show_progress "$current_size" "$estimated_final_size" "Compress"
            fi
            sleep 0.2
        done
        
        if [ -f "$temp_archive" ]; then
            local final_size=$(stat -c%s "$temp_archive")
            show_progress "$final_size" "$final_size" "Compress"
        fi
        
        echo
    ) &
    
    local progress_monitor_pid=$!
    
    tar -czf "$temp_archive" "${files[@]}" 2>/dev/null &
    compress_pid=$!
    
    if ! wait "$compress_pid"; then
        kill "$progress_monitor_pid" 2>/dev/null || true
        print_error "Failed to create archive"
        exit 1
    fi
    
    kill "$progress_monitor_pid" 2>/dev/null || true
    wait "$progress_monitor_pid" 2>/dev/null || true
    
    if [ ! -f "$temp_archive" ]; then
        print_error "Archive file was not created"
        exit 1
    fi
    
    local archive_size=$(stat -c%s "$temp_archive" 2>/dev/null || echo 0)
    if [ "$archive_size" -eq 0 ]; then
        print_error "Archive file is empty"
        rm -f "$temp_archive"
        exit 1
    fi
    
    print_info "Archive created: $(format_bytes "$archive_size")"
    echo
    
    print_info "Uploading to server..."
    
    local upload_progress_file="/tmp/dtlk_upload_progress_${timestamp}"
    local response_file="/tmp/dtlk_response_${timestamp}"
    local http_code_file="/tmp/dtlk_http_code_${timestamp}"
    
    (
        while [ ! -f "$upload_progress_file" ]; do
            sleep 0.1
        done
        
        while [ -f "$upload_progress_file" ]; do
            if [ -f "$response_file" ]; then
                local uploaded=$(stat -c%s "$response_file" 2>/dev/null || echo 0)
                if [ "$uploaded" -gt 0 ]; then
                    show_progress "$archive_size" "$archive_size" "Upload"
                    break
                fi
            fi
            show_progress 0 "$archive_size" "Upload"
            sleep 0.3
        done
    ) &
    
    progress_pid=$!
    
    echo "0" > "$upload_progress_file"
    
    if ! curl -X POST "$SERVER_URL/upload" \
        -F "file=@$temp_archive" \
        --output "$response_file" \
        --write-out "%{http_code}" \
        --silent \
        --show-error > "$http_code_file" 2>/dev/null; then
            
        rm -f "$temp_archive" "$http_code_file" "$response_file" "$upload_progress_file"
        kill "$progress_pid" 2>/dev/null || true
        print_error "Failed to connect to server at $SERVER_URL"
        exit 1
    fi
    
    rm -f "$upload_progress_file"
    kill "$progress_pid" 2>/dev/null || true
    wait "$progress_pid" 2>/dev/null || true
    echo
    
    local response_content=""
    local http_code=""
    
    if [ -f "$response_file" ]; then
        response_content=$(cat "$response_file" 2>/dev/null || echo "")
    fi
    
    if [ -f "$http_code_file" ]; then
        http_code=$(cat "$http_code_file" 2>/dev/null || echo "")
    fi
    
    rm -f "$temp_archive" "$response_file" "$http_code_file"
    
    if [ "$http_code" != "200" ]; then
        print_error "Upload failed (HTTP $http_code). Server response: $response_content"
        exit 1
    fi
    
    local file_id
    file_id=$(echo "$response_content" | grep -o '"id":"[0-9]*"' | grep -o '[0-9]*' | head -1)
    
    if [ -z "$file_id" ]; then
        print_error "Upload failed. Server response: $response_content"
        exit 1
    fi
    
    local formatted_id=$(printf "%08d" "$file_id")
    
    print_success "Upload successful!"
    echo
    echo "File ID: $formatted_id"
    echo
    print_info "Use 'dtlk down $formatted_id' to download"
}

get_unique_name() {
    local base_name="$1"
    local counter=1
    local new_name="$base_name"
    
    while [ -e "$new_name" ]; do
        if [ -d "$base_name" ]; then
            new_name="${base_name}_dups${counter}"
        else
            local name_without_ext="${base_name%.*}"
            local extension="${base_name##*.}"
            if [ "$name_without_ext" != "$base_name" ]; then
                new_name="${name_without_ext}_dups${counter}.${extension}"
            else
                new_name="${base_name}_dups${counter}"
            fi
        fi
        ((counter++))
    done
    
    echo "$new_name"
}

handle_duplicates() {
    local target_dir="$1"
    local temp_extract_dir="$2"
    local renamed_file="/tmp/dtlk_renamed_$(date +%s).txt"
    
    shopt -s dotglob
    
    for item in "$temp_extract_dir"/*; do
        [ ! -e "$item" ] && continue
        
        local item_name=$(basename "$item")
        [ "$item_name" = "." ] || [ "$item_name" = ".." ] && continue
        
        local target_path="$target_dir/$item_name"
        
        if [ -e "$target_path" ]; then
            local unique_name=$(get_unique_name "$target_path")
            local unique_basename=$(basename "$unique_name")
            
            print_info "File/directory '$item_name' already exists, renaming to '$unique_basename'"
            
            if ! mv "$item" "$unique_name"; then
                print_error "Failed to move $item to $unique_name"
                rm -f "$renamed_file"
                shopt -u dotglob
                return 1
            fi
            
            echo "$unique_basename" >> "$renamed_file"
        else
            if ! mv "$item" "$target_path"; then
                print_error "Failed to move $item to $target_path"
                rm -f "$renamed_file"
                shopt -u dotglob
                return 1
            fi
        fi
    done
    
    shopt -u dotglob
    
    if [ -f "$renamed_file" ] && [ -s "$renamed_file" ]; then
        echo
        print_info "Some files were renamed to avoid conflicts:"
        while IFS= read -r renamed_item; do
            echo "  → $renamed_item"
        done < "$renamed_file"
    fi
    
    rm -f "$renamed_file"
}

download_file() {
    local file_id="$1"
    local download_dir="${2:-.}"
    
    if [ -z "$file_id" ]; then
        print_error "No file ID specified"
        echo "Usage: $SCRIPT_NAME down <8-digit-id> [download-directory]"
        exit 1
    fi
    
    file_id=$(echo "$file_id" | sed 's/^0*//')
    if [ -z "$file_id" ]; then
        file_id="0"
    fi
    
    if ! [[ "$file_id" =~ ^[0-9]+$ ]]; then
        print_error "Invalid file ID: must be numeric"
        exit 1
    fi
    
    if [ "$download_dir" != "." ] && [ ! -d "$download_dir" ]; then
        print_info "Creating download directory: $download_dir"
        mkdir -p "$download_dir"
    fi
    
    local original_dir=$(pwd)
    cd "$download_dir"
    local abs_download_dir=$(pwd)
    cd "$original_dir"
    
    print_info "Downloading file..."
    temp_file="/tmp/dtlk_download_$(date +%s).tar.gz"
    
    local file_size=0
    local head_response=$(curl -s -I "$SERVER_URL/download/$file_id" 2>/dev/null)
    if [ $? -eq 0 ]; then
        file_size=$(echo "$head_response" | grep -i "content-length:" | sed 's/.*: *//' | tr -d '\r\n')
        if [ -n "$file_size" ] && [ "$file_size" -gt 0 ]; then
            print_info "File size: $(format_bytes "$file_size")"
            echo
        fi
    fi
    
    local download_progress_file="/tmp/dtlk_download_progress_$(date +%s)"
    
    if [ "$file_size" -gt 0 ]; then
        (
            while [ ! -f "$download_progress_file" ]; do
                sleep 0.1
            done
            
            while [ -f "$download_progress_file" ]; do
                if [ -f "$temp_file" ]; then
                    local current_size=$(stat -c%s "$temp_file" 2>/dev/null || echo 0)
                    show_progress "$current_size" "$file_size" "Download"
                fi
                sleep 0.3
            done
        ) &
        
        progress_pid=$!
        echo "0" > "$download_progress_file"
    fi
    
    local http_code
    if ! http_code=$(curl -X GET "$SERVER_URL/download/$file_id" \
        -o "$temp_file" \
        --progress-meter \
        --write-out "%{http_code}" \
        2>/dev/null); then
            
        rm -f "$temp_file" "$download_progress_file"
        [ -n "$progress_pid" ] && kill "$progress_pid" 2>/dev/null || true
        print_error "Failed to connect to server at $SERVER_URL"
        exit 1
    fi
    
    rm -f "$download_progress_file"
    [ -n "$progress_pid" ] && kill "$progress_pid" 2>/dev/null || true
    [ -n "$progress_pid" ] && wait "$progress_pid" 2>/dev/null || true
    echo
    
    if [ "$http_code" != "200" ]; then
        rm -f "$temp_file"
        if [ "$http_code" == "404" ]; then
            print_error "File not found (ID: $file_id)"
        else
            print_error "Download failed (HTTP $http_code)"
        fi
        exit 1
    fi
    
    if [ ! -f "$temp_file" ] || [ ! -s "$temp_file" ]; then
        rm -f "$temp_file"
        print_error "Download failed: no data received"
        exit 1
    fi
    
    local downloaded_size=$(stat -c%s "$temp_file" 2>/dev/null || echo 0)
    print_info "Downloaded: $(format_bytes "$downloaded_size")"
    echo
    
    temp_extract_dir="/tmp/dtlk_extract_$(date +%s)"
    mkdir -p "$temp_extract_dir"
    
    print_info "Extracting files..."
    
    local extract_progress_file="/tmp/dtlk_extract_progress_$(date +%s)"
    
    (
        while [ ! -f "$extract_progress_file" ]; do
            sleep 0.1
        done
        
        local last_size=0
        while [ -f "$extract_progress_file" ]; do
            if [ -d "$temp_extract_dir" ]; then
                local current_size=$(du -sb "$temp_extract_dir" 2>/dev/null | cut -f1 || echo 0)
                
                local estimated_final_size=$((downloaded_size * 3))
                
                if [ "$current_size" -gt "$estimated_final_size" ]; then
                    estimated_final_size=$((current_size + current_size / 10))
                fi
                
                if [ "$current_size" -ne "$last_size" ]; then
                    show_progress "$current_size" "$estimated_final_size" "Extract"
                    last_size=$current_size
                fi
            fi
            sleep 0.2
        done
    ) &
    
    local extract_progress_pid=$!
    echo "0" > "$extract_progress_file"
    
    if ! tar -xzf "$temp_file" -C "$temp_extract_dir" 2>/dev/null; then
        rm -f "$temp_file" "$extract_progress_file"
        rm -rf "$temp_extract_dir"
        kill "$extract_progress_pid" 2>/dev/null || true
        print_error "Failed to extract downloaded file"
        exit 1
    fi
    
    rm -f "$extract_progress_file"
    kill "$extract_progress_pid" 2>/dev/null || true
    wait "$extract_progress_pid" 2>/dev/null || true
    
    local extracted_size=$(du -sb "$temp_extract_dir" 2>/dev/null | cut -f1 || echo 0)
    show_progress "$extracted_size" "$extracted_size" "Extract"
    echo
    
    print_success "Extraction completed! ($(format_bytes "$extracted_size") extracted)"
    echo
    
    rm -f "$temp_file"
    
    if ! handle_duplicates "$abs_download_dir" "$temp_extract_dir"; then
        rm -rf "$temp_extract_dir"
        print_error "Failed to handle file conflicts"
        exit 1
    fi
    
    rm -rf "$temp_extract_dir"
    
    print_success "Download and extraction completed!"
    if [ "$download_dir" != "." ]; then
        print_info "Files extracted to: $download_dir"
    else
        print_info "Files extracted to current directory"
    fi
}


show_usage() {
    echo "DataLink Client - File upload/download tool"
    echo
    echo "Usage:"
    echo "  $SCRIPT_NAME up <file/directory> [additional files/directories...]"
    echo "  $SCRIPT_NAME down <8-digit-id> [download-directory]"
    echo
    echo "Examples:"
    echo "  $SCRIPT_NAME up myfile.txt"
    echo "  $SCRIPT_NAME up folder1/ file.txt folder2/"
    echo "  $SCRIPT_NAME down 12345678"
    echo "  $SCRIPT_NAME down 12345678 ./downloads/"
    echo
    echo "Server URL: $SERVER_URL"
}

main() {
    if [ $# -eq 0 ]; then
        show_usage
        exit 1
    fi
    
    check_dependencies
    
    case "$1" in
        "up")
            shift
            upload_files "$@"
            ;;
        "down")
            shift
            download_file "$@"
            ;;
        "-h"|"--help"|"help")
            show_usage
            ;;
        *)
            print_error "Unknown command: $1"
            echo
            show_usage
            exit 1
            ;;
    esac
}

main "$@" 